; based on https://github.com/jmatzen/leventhal-6809/blob/master/6809_MUL16.s
mul16_internal:
        ; use stack

        ldu ,s
        clra
        clrb
        std ,s
        pshs d

        lda	5,s
        ldb	7,s
        mul
        stb	3,s
        sta	2,s

        lda	5,S
        lda	6,S
        mul
        addb	2,S
        stb	2,S
        adca	#0
        sta	1,S

        lda	4,S
        ldb	7,S
        mul
        addb	2,S
        stb	2,S
        adca	1,S
        sta	1,S
        bcc	mul16_skip

        inc	,S

mul16_skip:
        lda	4,S
        ldb	6,S
        mul
        addb	1,S
        adca	,S

        ldx	2,S
        leas	 6,S
        pshs D,X
        jmp	,U




SREM16:
        LDA	#$FF		; INDICATE REMAINDER TO BE RETURNED
        STA	,-S		; SAVE INDICATOR ON STACK
        BRA	CHKSGN		; GO CHECK SIGNS
; SIGNED DIVISION, RETURNS QUOTIENT
;
SDIV16:
        CLR	,-S		; INDICATE QUOTIENT TO BE RETURNED
;
; IF DIVISOR IS NEGATIVE, TAKE ITS ABSOLUTE VALUE AND INDICATE
; THAT QUOTIENT IS NEGATIVE
;
CHKSGN:
        LDD	#0		; INDICATE QUOTIENT, REMAINDER POSITIVE
        PSHS	D		; SAVE INDICATOR ON STACK LEAX 5,8 POINT TO DIVISOR
        TST	,X		; CHECK IF DIVISOR IS POSITIVE
        BPL	CHKDVD		; BRANCH IF DIVISOR IS POSITIVE
        SUBD	,X		; ELSE TAKE ABSOLUTE VALUE OF DIVISOR
        STD	,X
        COM	1,S		; INDICATE QUOTIENT IS NEGATIVE
        BRA	CHKZRO
;
; IF DIVIDEND IS NEGATIVE,
; TAKE ITS ABSOLUTE VALUE,
; INDICATE THAT REMAINDER IS NEGATIVE,
; AND INVERT SIGN OF QUOTIENT
;
CHKDVD: LEAX	2,X		; POINT TO HIGH BYTE OF DIVIDEND
        TST	,X		; CHECK IF DIVIDEND IS POSITIVE
        BPL	CHKZRO		; BRANCH IF DIVIDEND IS POSITIVE
        LDD	#0		; ELSE TAKE ABSOLUTE VALUE OF DIVIDEND
        SUBD	,X
        COM	,S		; INDICATE REMAINDER IS NEGATIVE
        COM	1,S		; INVERT SIGN OF QUOTIENT
;
; UNSIGNED 16-BIT DIVISION, RETURNS QUOTIENT
;
UDIV16: CLR	,-S		; INDICATE QUOTIENT TO BE RETURNED
        BRA	CLRSGN
;
; UNSIGNED 16-BIT DIVISION, RETURNS REMAINDER
;
UREM16:
        LDA	#$FF		; INDICATE REMAINDER TO BE RETURNED
        STA	,-S
;
; UNSIGNED DIVISION, INDICATE QUOTIENT, REMAINDER BOTH POSITIVE
;
CLRSGN:
        LDD	#0		; INDICATE QUOTIENT, REMAINDER POSITIVE
        PSHS	D
;
; CHECK FOR ZERO DIVISOR
; EXIT, INDICATING ERROR, IF FOUND
;
CHKZRO:
        LEAX	5,S		; POINT TO DIVISOR
        LDD	,X		; TEST DIVISOR
        BNE	STRTDV		; BRANCH IF DIVISOR NOT ZERO
        STD	2,X		; DIVISOR IS ZERO, SO MAKE RESULT ZERO
;--	SEC			; INDICATE DIVIDE BY ZERO ERROR
        ORCC	#1
        BRA	EXITDV		; EXIT INDICATING ERROR
;
; DIVIDE UNSIGNED DIVIDEND BY UNSIGNED DIVISOR
; MEMORY ADDRESSES HOLD BOTH DIVIDEND AND QUOTIENT.
; EACH TIME WE SHIFT THE DIVIDEND ONE BIT LEFT,
; WE ALSO SHIFT A BIT OF THE
; QUOTIENT IN FROM THE CARRY AT THE FAR RIGHT
; AT THE END, THE QUOTIENT HAS REPLACED THE DIVIDEND IN MEMORY
; AND THE REMAINDER IS LEFT IN REGISTER D
;
STRTDV: LDD	#0		; EXTEND DIVIDEND TO 32 BITS WITH 0
        LDY	#16		; BIT COUNT = 16
;--	CLC			; START CARRY AT ZERO
        ANDCC	#$FE
;
; SHIFT DIVIDEND LEFT WITH ENTERING AT FAR RIGHT
;
DIV16:
        ROL	3,X		; SHIFT LOW  BYTE OF DIVIDEND
                                ; QUOTIENT BIT ENTERS FROM CARRY
        ROL	2,X		; SHIFT NEXT BYTE OF DIVIDEND
        ROLB			; SHIFT NEXT BYTE OF DIVIDEND
        ROLA			; SHIFT HIGH BYTE OF DIVIDEND
;
; DO A TRIAL SUBTRACTION OF DIVISOR FROM DIVIDEND
; IF DIFFERENCE IS NON-NEGATIVE, SET NEXT BIT OF QUOTIENT.
; PERFORM ACTUAL SUBTRACTION, REPLACING QUOTIENT WITH DIFFERENCE.
; IF DIFFERENCE IS NEGATIVE, CLEAR NEXT BIT OF QUOTIENT
;
        CMPD	,X		; TRIAL SUBTRACTION OF DIVISOR
        BCS	CLRCRY		; BRANCH IF SUBTRACTION FAILS
        SUBD	,X		; TRIAL SUBTRACTION SUCCEEDED,
                                ; SO SUBTRACT DIVISOR FROM
                                ; DIVIDEND
;--	SEC			; SET NEXT BIT OF QUOTIENT TO 1
        ORCC	#1
        BRA	DECCNT
CLRCRY:
;--	CLC			; TRIAL SUBTRACTION FAILED, SO
        ANDCC	#$FE
                                ; SET NEXT BIT OF QUOTIENT TO 0
;
; UPDATE BIT COUNTER
; CONTINUE THROUGH 16 BITS
;
DECCNT: LEAY	-1,Y		; CONTINUE UNTIL ALL BITS DONE
        BNE	DIV16
;
; SHIFT LAST CARRY INTO QUOTIENT
;
        ROL	3,X		; SHIFT LAST CARRY INTO QUOTIENT
        ROL	2,X		; INCLUDING MORE SIGNIFICANT BYTE
;
; SAVE REMAINDER IN STACK
; NEGATE REMAINDER IF INDICATOR SHOWS IT IS NEGATIVE
;
        STD	,X		; SAVE REMAINDER IN STACK
        TST	,S		; CHECK IF REMAINDER IS POSITIVE
        BEQ	TSTQSN
                                ; BRANCH IF REMAINDER IS POSITIVE
        LDD	#0		; ELSE NEGATE IT
        STD	,X		; SAVE NEGATIVE REMAINDER
;
; NEGATE QUOTIENT IF INDICATOR SHOWS IT IS NEGATIVE
;
TSTQSN: TST	1,S		; CHECK IF QUOTIENT IS POSITIVE
        BEQ	TSTRTN		; BRANCH IF QUOTIENT IS POSITIVE LDD #0 ELSE NEGATE IT
        SUBD	7,S
        STD	7,S		; SAVE NEGATIVE QUOTIENT
;
; SAVE QUDTIENT OR REMAINDER, DEPENDING ON FLAG IN STACK
;
TSTRTN:
;--	CLC			; INDICATE NO DIVIDEBYZERO ERROR
        ANDCC	#$FE
        TST	2,S		; TEST QUOTIENT/REMAINDER FLAG
        BEQ	EXITDV		; BRANCH TO RETURN QUOTIENT
        LDD	,X		; REPLACE QUOTIENT WITH REMAINDER
        STD	7,S
; REMOVE PARAMETERS FROM STACK AND EXIT
;
EXITDV:	LDX	3,S		; SAVE RETURN ADDRESS
        LEAS	7,S		; REMOVE PARAMETERS FROM STACK
        JMP	,X		; EXIT TO RETURN ADDRESS
